{
  # Photo garden packages
  workspace, apps, jobs,

  # Config
  prod, dockerTag, dockerImagePrefix,

  # Dependencies
  lib,
  dockerTools, skopeo,
  linkFarm, symlinkJoin, runCommand, writeText,
  bashInteractive, coreutils, less, nodejs, remarshal,
  callPackage,
}:
let
  relativizePath = base: path: lib.removePrefix (toString base + "/") (toString path);
  pkgAndDeps = pkg: [pkg] ++ lib.attrValues pkg.workspaceDependencies;

  symlinkAddPkg = pkg: symlinkJoin {
    name = "${pkg.name}-symlinkJoin";
    paths = pkg;
  };

  # Adapted from https://github.com/xtruder/kubenix/blob/bc37b314ee5123da9f61721e2845291a2fdd0e58/k8s.nix
  loadYAML = path: builtins.fromJSON (builtins.readFile (runCommand "yaml-to-json" {} "${remarshal}/bin/remarshal -i ${path} -if yaml -of json > $out"));

  dockerImageRef = app: "${dockerImagePrefix}${app}:${dockerTag}";
in rec {
  imageConfig = if prod
    then ./config.production.json
    else ./config.development.json;
  imageConfigDir = linkFarm "config" [ {
    name = "photo-garden.json";
    path = imageConfig;
  } ];
  baseImage = dockerTools.buildImage {
    name = "photo-garden-base";
    keepContentsDirlinks = true;
    contents = map symlinkAddPkg [
      # Debugging
      bashInteractive
      coreutils
      less
      # /usr/bin/env
      (linkFarm "photo-garden-base-overlay" [{
        name = "usr";
        path = linkFarm "photo-garden-base-usr" [{
          name = "bin";
          path = linkFarm "photo-garden-base-usr-bin" [{
            name = "env";
            path = "${coreutils}/bin/env";
          }];
        }];
      }])
      # Shared packages to reduce duplication
      nodejs
    ];
  };
  appImages = lib.listToAttrs (map (name: lib.nameValuePair name (dockerTools.buildImage {
    inherit name;
    fromImage = if workspace.${name}.useBaseLayer or true
      then baseImage
      else null;
    keepContentsDirlinks = true;
    contents = [ imageConfigDir workspace.${name} ];
    config =
    let
      pkg = workspace.${name};
      pkgBin = "/bin/${name}";
      nodemonConfig = {
        watch = map (dep: "/node_modules/${dep.pname}") (pkgAndDeps pkg) ++ ["/photo-garden.json"];
        # By default nodemon ignores everything inside node_modules
        ignoreRoot = [];
      };
      nodemonConfigJSON = writeText "nodemon.json" (builtins.toJSON nodemonConfig);
    in {
      Cmd = if (!prod) && (pkg.useNodemon or true)
        then [ "/node_modules/nodemon/bin/nodemon.js" "--exec" "${nodejs}/bin/node" "--config" nodemonConfigJSON pkgBin ]
        else [ pkgBin ];
      Env = [
        "PHOTO_GARDEN_CONFIG=/photo-garden.json"
        "APP_NAME=${name}"
      ];
    };
  })) (apps ++ jobs));
  images = lib.mapAttrsToList (name: img: {
    name = "${name}.docker.tar.gz";
    path = img;
  }) appImages ++ [{
    name = "docker-base.tar.gz";
    path = baseImage;
  }];

  composeFileBase = loadYAML ./docker-compose.template.yml;
  composeFileOverrides = {
    services = lib.listToAttrs (map (name: rec {
      inherit name;
      existingService = (composeFileBase.services or {}).${name} or {};
      value = {
        image = dockerImageRef name;
        volumes =
        let
          existing = existingService.volumes or [];
          dependencyVolumes = map (dep: "./${relativizePath ./. dep.src}:/node_modules/${dep.pname}") (pkgAndDeps workspace.${name});
          configVolume = "./${relativizePath ./. imageConfig}:/photo-garden.json";
        in existing ++ lib.optionals (!prod) (dependencyVolumes ++ [configVolume]);
        environment = (existingService.environment or []) ++ [
          "LOG_LEVEL"
        ];
      };
    }) (apps ++ jobs));
  };
  composeFileData = lib.recursiveUpdate composeFileBase composeFileOverrides;
  composeFile = writeText "docker-compose.yml"
    ''
      # DO NOT EDIT DIRECTLY, THIS WAS GENERATED BY composeFile in docker.nix
      # Instead, edit docker-compose.template.yml, and run ./build-docker.sh to regenerate
      ${builtins.toJSON composeFileData}
    '';

  kubernetesConfig = callPackage ./kubernetes.nix {
    inherit apps jobs appImages dockerImageRef loadYAML;
  };

  skopeoLoadImgMap = targetProto: name: img: "docker-archive:${img} ${targetProto}${dockerImageRef name}";
  skopeoLoadImgsMap = targetProto: lib.concatStringsSep "\n" (lib.mapAttrsToList (skopeoLoadImgMap targetProto) appImages);
  skopeoLoadMap = writeText "docker-load" (skopeoLoadImgsMap "docker-daemon:");
  skopeoUploadMap = writeText "docker-upload" (skopeoLoadImgsMap "docker://");
  dockerEnv = writeText "docker-env"
    ''
      export DOCKER_IMAGE_PREFIX=${dockerImagePrefix}
      export DOCKER_TAG=${dockerTag}
    '';

  extraFiles = [
    {
      name = "docker-compose.yml";
      path = composeFile;
    }
    {
      name = "kubernetes";
      path = kubernetesConfig;
    }
    {
      name = "docker-env";
      path = dockerEnv;
    }
    {
      name = "skopeo-load-map";
      path = skopeoLoadMap;
    }
    {
      name = "skopeo-upload-map";
      path = skopeoUploadMap;
    }
  ];
}
